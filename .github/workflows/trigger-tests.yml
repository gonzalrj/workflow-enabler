name: Trigger remote regression and fetch reports

on:
  push:
    branches:
      - main

env:
  REMOTE_OWNER: gonzalrj
  REMOTE_REPO: qa-practice-swaglabs
  REMOTE_WORKFLOW_FILE: manual-regression-sharded.yml
  REMOTE_BRANCH: main
  POLL_INTERVAL_SECONDS: 10
  TIMEOUT_MINUTES: 30

jobs:
  trigger-and-wait:
    runs-on: ubuntu-latest
    steps:
      - name: Install jq (for JSON parsing)
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Dispatch remote workflow via REST
        id: dispatch
        env:
          OWNER: ${{ env.REMOTE_OWNER }}
          REPO: ${{ env.REMOTE_REPO }}
          WORKFLOW: ${{ env.REMOTE_WORKFLOW_FILE }}
          REF: ${{ env.REMOTE_BRANCH }}
          PAT: ${{ secrets.REMOTE_PAT }}
        run: |
          set -euo pipefail
          echo "Dispatching workflow ${WORKFLOW} on ${OWNER}/${REPO} -> ref=${REF}"
          # Use safe JSON payload
          payload=$(jq -n --arg r "${REF}" '{ref: $r}')
          http_status=$(curl -sS -o /dev/stderr -w "%{http_code}" -X POST \
            -H "Authorization: Bearer ${PAT}" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${OWNER}/${REPO}/actions/workflows/${WORKFLOW}/dispatches" \
            -d "$payload" ) || true

          echo "Dispatch HTTP status: $http_status"
          if [ "$http_status" != "204" ]; then
            echo "Dispatch failed (status $http_status). To debug, re-run with verbose curl or check permissions and that the remote workflow has 'on: workflow_dispatch'."
            exit 1
          fi
          echo "Dispatched successfully."

      - name: Poll for remote workflow run id and wait for completion
        id: poll
        env:
          OWNER: ${{ env.REMOTE_OWNER }}
          REPO: ${{ env.REMOTE_REPO }}
          WORKFLOW: ${{ env.REMOTE_WORKFLOW_FILE }}
          REF: ${{ env.REMOTE_BRANCH }}
          PAT: ${{ secrets.REMOTE_PAT }}
          POLL_INTERVAL: ${{ env.POLL_INTERVAL_SECONDS }}
          TIMEOUT: ${{ env.TIMEOUT_MINUTES }}
        run: |
          set -euo pipefail
          poll_interval=${POLL_INTERVAL}
          timeout_seconds=$(( TIMEOUT * 60 ))
          start_ts=$(date +%s)
          echo "Waiting up to ${TIMEOUT} minutes for remote run to appear and complete..."

          run_id=""
          # Wait for the new run to appear (we will take the most recent run for that workflow+branch)
          while true; do
            now=$(date +%s)
            elapsed=$(( now - start_ts ))
            if [ $elapsed -ge $timeout_seconds ]; then
              echo "Timed out waiting for remote run to appear (after ${TIMEOUT} minutes)."
              exit 2
            fi

            runs_resp=$(curl -sS -H "Authorization: Bearer ${PAT}" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/${OWNER}/${REPO}/actions/workflows/${WORKFLOW}/runs?branch=${REF}&event=workflow_dispatch&per_page=5")

            # pick the most recent run id
            run_id=$(echo "$runs_resp" | jq -r '.workflow_runs[0].id // empty')
            run_created_at=$(echo "$runs_resp" | jq -r '.workflow_runs[0].created_at // empty')
            run_status=$(echo "$runs_resp" | jq -r '.workflow_runs[0].status // empty')
            run_conclusion=$(echo "$runs_resp" | jq -r '.workflow_runs[0].conclusion // empty')

            if [ -n "$run_id" ]; then
              echo "Found run: id=$run_id created_at=$run_created_at status=$run_status conclusion=$run_conclusion"
              break
            fi

            sleep $poll_interval
          done

          # Wait for completion
          while true; do
            now=$(date +%s)
            elapsed=$(( now - start_ts ))
            if [ $elapsed -ge $timeout_seconds ]; then
              echo "Timed out waiting for remote run to finish (after ${TIMEOUT} minutes)."
              exit 2
            fi

            run_resp=$(curl -sS -H "Authorization: Bearer ${PAT}" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/${OWNER}/${REPO}/actions/runs/${run_id}")

            status=$(echo "$run_resp" | jq -r '.status // empty')
            conclusion=$(echo "$run_resp" | jq -r '.conclusion // empty')
            echo "Remote run id=${run_id} status=${status} conclusion=${conclusion}"

            if [ "$status" = "completed" ]; then
              echo "Remote run completed with conclusion=${conclusion}"
              echo "RUN_ID=${run_id}" >> $GITHUB_OUTPUT
              echo "RUN_CONCLUSION=${conclusion}" >> $GITHUB_OUTPUT
              break
            fi

            sleep $poll_interval
          done

      - name: Download remote artifacts (if successful)
        if: ${{ steps.poll.outputs.RUN_CONCLUSION == 'success' }}
        env:
          OWNER: ${{ env.REMOTE_OWNER }}
          REPO: ${{ env.REMOTE_REPO }}
          PAT: ${{ secrets.REMOTE_PAT }}
          RUN_ID: ${{ steps.poll.outputs.RUN_ID }}
        run: |
          set -euo pipefail
          echo "Fetching artifacts for run ${RUN_ID}..."
          artifacts_json=$(curl -sS -H "Authorization: Bearer ${PAT}" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${OWNER}/${REPO}/actions/runs/${RUN_ID}/artifacts")

          total=$(echo "$artifacts_json" | jq -r '.total_count // 0')
          echo "Artifact total_count = $total"
          if [ "$total" -eq 0 ]; then
            echo "No artifacts to download."
            exit 0
          fi

          mkdir -p remote_artifacts
          for id in $(echo "$artifacts_json" | jq -r '.artifacts[].id'); do
            name=$(echo "$artifacts_json" | jq -r ".artifacts[] | select(.id==${id}) | .name")
            echo "Downloading artifact id=$id name=$name"
            # GitHub returns a redirect, use -L
            curl -sSL -H "Authorization: Bearer ${PAT}" \
              -H "Accept: application/octet-stream" \
              "https://api.github.com/repos/${OWNER}/${REPO}/actions/artifacts/${id}/zip" \
              --output "remote_artifacts/${name}_${id}.zip"
          done

      - name: Upload remote artifacts so they can be downloaded from this run
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: remote-artifacts
          path: remote_artifacts/*.zip
