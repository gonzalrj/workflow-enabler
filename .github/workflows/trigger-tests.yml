name: Trigger remote regression and link to consolidated artifact

on:
  push:
    branches:
      - main

env:
  REMOTE_OWNER: gonzalrj
  REMOTE_REPO: qa-practice-swaglabs
  REMOTE_WORKFLOW_FILE: manual-regression-sharded.yml
  REMOTE_BRANCH: main
  POLL_INTERVAL_SECONDS: 10
  TIMEOUT_MINUTES: 90

jobs:
  trigger-remote:
    runs-on: ubuntu-latest

    steps:
      - name: Install jq
        run: sudo apt-get update -y && sudo apt-get install -y jq

      - name: Record trigger timestamp (UTC)
        id: ts
        run: |
          echo "trigger_ts=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_OUTPUT

      - name: Dispatch remote workflow via REST
        id: dispatch
        env:
          PAT: ${{ secrets.REMOTE_PAT }}
        run: |
          set -euo pipefail
          echo "Dispatching remote workflow ${REMOTE_WORKFLOW_FILE} -> ${REMOTE_OWNER}/${REMOTE_REPO}@${REMOTE_BRANCH}"
          payload=$(jq -n --arg ref "${REMOTE_BRANCH}" '{ref: $ref}')
          http_status=$(curl -sS -o /dev/stderr -w "%{http_code}" -X POST \
            -H "Authorization: token ${PAT}" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${REMOTE_OWNER}/${REMOTE_REPO}/actions/workflows/${REMOTE_WORKFLOW_FILE}/dispatches" \
            -d "${payload}" ) || true

          echo "Dispatch HTTP status: ${http_status}"
          if [ "${http_status}" != "204" ]; then
            echo "Failed to dispatch remote workflow (HTTP ${http_status}). Ensure REMOTE_PAT has repo+workflow scopes and remote workflow has 'on: workflow_dispatch'."
            exit 1
          fi
          echo "Dispatched successfully."

      - name: Find the NEW run triggered by this workflow (epoch compare)
        id: findrun
        env:
          PAT: ${{ secrets.REMOTE_PAT }}
          TRIGGER_TS: ${{ steps.ts.outputs.trigger_ts }}
          POLL_INTERVAL_SECONDS: ${{ env.POLL_INTERVAL_SECONDS }}
          TIMEOUT_MINUTES: ${{ env.TIMEOUT_MINUTES }}
        run: |
          set -euo pipefail
          echo "Looking for a run created at or after $TRIGGER_TS (1s tolerance)"

          trigger_epoch=$(date -u -d "${TRIGGER_TS}" +%s)
          echo "trigger_epoch=${trigger_epoch}"

          timeout=$(( TIMEOUT_MINUTES * 60 ))
          start_ts=$(date +%s)

          run_id=""
          while [ -z "$run_id" ]; do
            now=$(date +%s)
            if [ $(( now - start_ts )) -gt $timeout ]; then
              echo "Timed out waiting for new run to appear after ${TIMEOUT_MINUTES} minutes."
              exit 2
            fi

            runs_json=$(curl -sS -H "Authorization: token ${PAT}" \
              "https://api.github.com/repos/${REMOTE_OWNER}/${REMOTE_REPO}/actions/workflows/${REMOTE_WORKFLOW_FILE}/runs?branch=${REMOTE_BRANCH}&per_page=30")

            run_id_candidate=$(echo "$runs_json" | jq -r '.workflow_runs[] | "\(.id) \(.created_at)"' | while read -r id created_at; do
              run_epoch=$(date -u -d "${created_at}" +%s 2>/dev/null || echo 0)
              if [ "$run_epoch" -ge $(( trigger_epoch - 1 )) ]; then
                echo "$id"
                break
              fi
            done)

            if [ -n "$run_id_candidate" ]; then
              run_id="$run_id_candidate"
              echo "Found new run ID: $run_id"
              echo "run_id=${run_id}" >> $GITHUB_OUTPUT
              break
            fi

            echo "No new run found yet; sleeping ${POLL_INTERVAL_SECONDS}s..."
            sleep "${POLL_INTERVAL_SECONDS}"
          done

      - name: Wait for the run to finish (tracks the run we found)
        id: wait
        env:
          PAT: ${{ secrets.REMOTE_PAT }}
          RUN_ID: ${{ steps.findrun.outputs.run_id }}
          POLL_INTERVAL_SECONDS: ${{ env.POLL_INTERVAL_SECONDS }}
          TIMEOUT_MINUTES: ${{ env.TIMEOUT_MINUTES }}
        run: |
          set -euo pipefail
          if [ -z "${RUN_ID}" ]; then
            echo "No run id provided; aborting."
            exit 1
          fi
          echo "Tracking run ${RUN_ID} until completion..."

          timeout=$(( TIMEOUT_MINUTES * 60 ))
          start_ts=$(date +%s)

          while true; do
            now=$(date +%s)
            if [ $(( now - start_ts )) -gt $timeout ]; then
              echo "Timed out waiting for run ${RUN_ID} to finish after ${TIMEOUT_MINUTES} minutes."
              exit 3
            fi

            run_json=$(curl -sS -H "Authorization: token ${PAT}" \
              "https://api.github.com/repos/${REMOTE_OWNER}/${REMOTE_REPO}/actions/runs/${RUN_ID}")

            status=$(echo "$run_json" | jq -r '.status // ""')
            conclusion=$(echo "$run_json" | jq -r '.conclusion // ""')

            echo "run_id=${RUN_ID} status=${status} conclusion=${conclusion}"

            if [ "${status}" = "completed" ]; then
              echo "conclusion=${conclusion}" >> $GITHUB_OUTPUT
              break
            fi

            sleep "${POLL_INTERVAL_SECONDS}"
          done

      - name: Resolve only the consolidated (latest) artifact and output link
        id: consolidated_artifact
        env:
          PAT: ${{ secrets.REMOTE_PAT }}
          RUN_ID: ${{ steps.findrun.outputs.run_id }}
          REMOTE_OWNER: ${{ env.REMOTE_OWNER }}
          REMOTE_REPO: ${{ env.REMOTE_REPO }}
        run: |
          set -euo pipefail
          run_id="${RUN_ID}"
          echo "Fetching artifacts for run ${run_id}..."
          artifacts_json=$(curl -sS -H "Authorization: token ${PAT}" \
            "https://api.github.com/repos/${REMOTE_OWNER}/${REMOTE_REPO}/actions/runs/${run_id}/artifacts")

          total=$(echo "$artifacts_json" | jq -r '.total_count // 0')
          echo "Artifact total_count = $total"

          if [ "$total" -eq 0 ]; then
            echo "No artifacts found for run ${run_id}."
            echo "remote_run_url=https://github.com/${REMOTE_OWNER}/${REMOTE_REPO}/actions/runs/${run_id}" >> $GITHUB_OUTPUT
            echo "remote_artifact_url=" >> $GITHUB_OUTPUT
            exit 0
          fi

          # select the artifact with the latest created_at timestamp (consolidated/latest)
          # use jq to sort_by(created_at) and pick last
          latest_id=$(echo "$artifacts_json" | jq -r '.artifacts | sort_by(.created_at) | .[-1].id // empty')
          latest_name=$(echo "$artifacts_json" | jq -r '.artifacts | sort_by(.created_at) | .[-1].name // empty')

          if [ -z "$latest_id" ]; then
            echo "Could not determine latest artifact id."
            echo "remote_run_url=https://github.com/${REMOTE_OWNER}/${REMOTE_REPO}/actions/runs/${run_id}" >> $GITHUB_OUTPUT
            echo "remote_artifact_url=" >> $GITHUB_OUTPUT
            exit 0
          fi

          artifact_url="https://github.com/${REMOTE_OWNER}/${REMOTE_REPO}/actions/runs/${run_id}/artifacts/${latest_id}"
          echo "Selected latest artifact: id=${latest_id} name=${latest_name}"
          echo "artifact_url=${artifact_url}"

          echo "remote_run_url=https://github.com/${REMOTE_OWNER}/${REMOTE_REPO}/actions/runs/${run_id}" >> $GITHUB_OUTPUT
          echo "remote_artifact_url=${artifact_url}" >> $GITHUB_OUTPUT
          echo "remote_artifact_name=${latest_name}" >> $GITHUB_OUTPUT

      - name: Print final summary
        run: |
          echo "=========================="
          echo "REMOTE RUN SUMMARY"
          echo "=========================="
          echo "Run page: ${{ steps.consolidated_artifact.outputs.remote_run_url }}"
          echo ""
          echo "Consolidated artifact name: ${{ steps.consolidated_artifact.outputs.remote_artifact_name }}"
          echo "Consolidated artifact download URL:"
          echo "${{ steps.consolidated_artifact.outputs.remote_artifact_url }}"
          echo "=========================="

      - name: Fail if remote run finished but did not succeed
        if: ${{ steps.wait.outputs.conclusion != '' && steps.wait.outputs.conclusion != 'success' }}
        run: |
          echo "Remote workflow finished with conclusion: '${{ steps.wait.outputs.conclusion }}'. Marking as failed."
          exit 1

      - name: Succeed if remote run passed
        if: ${{ steps.wait.outputs.conclusion == 'success' }}
        run: echo "Remote workflow passed"
