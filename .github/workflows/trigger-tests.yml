name: Trigger remote regression and link to report (robust run detection + artifact links)

on:
  push:
    branches:
      - main

env:
  REMOTE_OWNER: gonzalrj
  REMOTE_REPO: qa-practice-swaglabs
  REMOTE_WORKFLOW_FILE: manual-regression-sharded.yml
  REMOTE_BRANCH: main
  POLL_INTERVAL_SECONDS: 10
  TIMEOUT_MINUTES: 90

jobs:
  trigger-remote:
    runs-on: ubuntu-latest

    steps:
      - name: Install jq
        run: sudo apt-get update -y && sudo apt-get install -y jq

      - name: Record trigger timestamp (UTC)
        id: ts
        run: |
          echo "trigger_ts=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_OUTPUT

      - name: Dispatch remote workflow via REST
        id: dispatch
        env:
          PAT: ${{ secrets.REMOTE_PAT }}
        run: |
          set -euo pipefail
          echo "Dispatching remote workflow ${REMOTE_WORKFLOW_FILE} -> ${REMOTE_OWNER}/${REMOTE_REPO}@${REMOTE_BRANCH}"
          payload=$(jq -n --arg ref "${REMOTE_BRANCH}" '{ref: $ref}')
          http_status=$(curl -sS -o /dev/stderr -w "%{http_code}" -X POST \
            -H "Authorization: token ${PAT}" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${REMOTE_OWNER}/${REMOTE_REPO}/actions/workflows/${REMOTE_WORKFLOW_FILE}/dispatches" \
            -d "${payload}" ) || true

          echo "Dispatch HTTP status: ${http_status}"
          if [ "${http_status}" != "204" ]; then
            echo "Failed to dispatch remote workflow (HTTP ${http_status}). Ensure REMOTE_PAT has repo+workflow scopes and remote workflow has 'on: workflow_dispatch'."
            exit 1
          fi
          echo "Dispatched successfully."

      - name: Find the NEW run triggered by this workflow (epoch compare)
        id: findrun
        env:
          PAT: ${{ secrets.REMOTE_PAT }}
          TRIGGER_TS: ${{ steps.ts.outputs.trigger_ts }}
          POLL_INTERVAL_SECONDS: ${{ env.POLL_INTERVAL_SECONDS }}
          TIMEOUT_MINUTES: ${{ env.TIMEOUT_MINUTES }}
        run: |
          set -euo pipefail
          echo "Looking for a run created at or after $TRIGGER_TS (1s tolerance)"

          trigger_epoch=$(date -u -d "${TRIGGER_TS}" +%s)
          echo "trigger_epoch=${trigger_epoch}"

          timeout=$(( TIMEOUT_MINUTES * 60 ))
          start_ts=$(date +%s)

          run_id=""
          while [ -z "$run_id" ]; do
            now=$(date +%s)
            if [ $(( now - start_ts )) -gt $timeout ]; then
              echo "Timed out waiting for new run to appear after ${TIMEOUT_MINUTES} minutes."
              exit 2
            fi

            runs_json=$(curl -sS -H "Authorization: token ${PAT}" \
              "https://api.github.com/repos/${REMOTE_OWNER}/${REMOTE_REPO}/actions/workflows/${REMOTE_WORKFLOW_FILE}/runs?branch=${REMOTE_BRANCH}&per_page=30")

            run_id_candidate=$(echo "$runs_json" | jq -r '.workflow_runs[] | "\(.id) \(.created_at)"' | while read -r id created_at; do
              run_epoch=$(date -u -d "${created_at}" +%s 2>/dev/null || echo 0)
              if [ "$run_epoch" -ge $(( trigger_epoch - 1 )) ]; then
                echo "$id"
                break
              fi
            done)

            if [ -n "$run_id_candidate" ]; then
              run_id="$run_id_candidate"
              echo "Found new run ID: $run_id"
              echo "run_id=${run_id}" >> $GITHUB_OUTPUT
              break
            fi

            echo "No new run found yet; sleeping ${POLL_INTERVAL_SECONDS}s..."
            sleep "${POLL_INTERVAL_SECONDS}"
          done

      - name: Wait for the run to finish (tracks the run we found)
        id: wait
        env:
          PAT: ${{ secrets.REMOTE_PAT }}
          RUN_ID: ${{ steps.findrun.outputs.run_id }}
          POLL_INTERVAL_SECONDS: ${{ env.POLL_INTERVAL_SECONDS }}
          TIMEOUT_MINUTES: ${{ env.TIMEOUT_MINUTES }}
        run: |
          set -euo pipefail
          if [ -z "${RUN_ID}" ]; then
            echo "No run id provided; aborting."
            exit 1
          fi
          echo "Tracking run ${RUN_ID} until completion..."

          timeout=$(( TIMEOUT_MINUTES * 60 ))
          start_ts=$(date +%s)

          while true; do
            now=$(date +%s)
            if [ $(( now - start_ts )) -gt $timeout ]; then
              echo "Timed out waiting for run ${RUN_ID} to finish after ${TIMEOUT_MINUTES} minutes."
              exit 3
            fi

            run_json=$(curl -sS -H "Authorization: token ${PAT}" \
              "https://api.github.com/repos/${REMOTE_OWNER}/${REMOTE_REPO}/actions/runs/${RUN_ID}")

            status=$(echo "$run_json" | jq -r '.status // ""')
            conclusion=$(echo "$run_json" | jq -r '.conclusion // ""')

            echo "run_id=${RUN_ID} status=${status} conclusion=${conclusion}"

            if [ "${status}" = "completed" ]; then
              echo "conclusion=${conclusion}" >> $GITHUB_OUTPUT
              break
            fi

            sleep "${POLL_INTERVAL_SECONDS}"
          done

      - name: Resolve artifact direct download URLs and output links
        id: artifact_links
        env:
          PAT: ${{ secrets.REMOTE_PAT }}
          RUN_ID: ${{ steps.findrun.outputs.run_id }}
        run: |
          set -euo pipefail
          run_id="${RUN_ID}"
          echo "Fetching artifacts for run ${run_id}..."
          artifacts_json=$(curl -sS -H "Authorization: token ${PAT}" \
            "https://api.github.com/repos/${REMOTE_OWNER}/${REMOTE_REPO}/actions/runs/${run_id}/artifacts")

          total=$(echo "$artifacts_json" | jq -r '.total_count // 0')
          echo "Artifact total_count = $total"

          if [ "$total" -eq 0 ]; then
            echo "No artifacts found for run ${run_id}."
            echo "remote_run_url=https://github.com/${REMOTE_OWNER}/${REMOTE_REPO}/actions/runs/${run_id}" >> $GITHUB_OUTPUT
            echo "remote_artifact_urls=" >> $GITHUB_OUTPUT
            echo "No artifacts to list."
            exit 0
          fi

          # Build newline-separated list of artifact download URLs
          urls=""
          names=""
          for row in $(echo "$artifacts_json" | jq -r '.artifacts[] | @base64'); do
            _jq() { echo "${row}" | base64 --decode | jq -r "${1}"; }
            id=$(_jq '.id')
            name=$(_jq '.name')
            url="https://github.com/${REMOTE_OWNER}/${REMOTE_REPO}/actions/runs/${run_id}/artifacts/${id}"
            echo "Artifact: ${name} -> ${url}"
            if [ -z "$urls" ]; then
              urls="${url}"
              names="${name}:${id}"
            else
              urls="${urls}\n${url}"
              names="${names}\t${name}:${id}"
            fi
          done

          # expose outputs (urls newline-separated, names tab-separated)
          echo "remote_run_url=https://github.com/${REMOTE_OWNER}/${REMOTE_REPO}/actions/runs/${run_id}" >> $GITHUB_OUTPUT
          # encode newlines safely for GitHub output
          echo -e "remote_artifact_urls<<EOF\n${urls}\nEOF" >> $GITHUB_OUTPUT
          echo "remote_artifact_names=${names}" >> $GITHUB_OUTPUT

      - name: Print final summary
        run: |
          echo "=========================="
          echo "REMOTE RUN SUMMARY"
          echo "=========================="
          echo "Run page: ${{ steps.artifact_links.outputs.remote_run_url }}"
          echo ""
          echo "Artifact download URLs:"
          # print multiline output safely
          echo -e "${{ steps.artifact_links.outputs.remote_artifact_urls }}"
          echo "=========================="

      - name: Fail if remote run finished but did not succeed
        if: ${{ steps.wait.outputs.conclusion != '' && steps.wait.outputs.conclusion != 'success' }}
        run: |
          echo "Remote workflow finished with conclusion: '${{ steps.wait.outputs.conclusion }}'. Marking as failed."
          exit 1

      - name: Succeed if remote run passed
        if: ${{ steps.wait.outputs.conclusion == 'success' }}
        run: echo "Remote workflow passed âœ…"
